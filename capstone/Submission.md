# Capstone Documentation Instructions

Please add the following items to the `/capstone/portfolio` directory and ensure they are 
pushed up by Monday, May 3rd

* A zip file of the `/src` director named `/capstone/portfolio/source.zip`
* A PDF named `/capstone/portfolio/<first_name>_<last_name>_portfolio.pdf` where
    * `<first_name>` is your first name
    * `<last_name>` is your last name

The PDF should contain all the sections outlined in `Capstone.md`.  You may use whatever software
you want to author the PDF.

Notes on each section

* Section 1: Program - include a link to the zip file mentioned above
* Section 2: Teamwork - Discuss your partners documentation and testing contribution, as well as your primary work on the project
* Section 3: Design pattern - We are going to memoize type access in the review session
* Section 4: Technical Writing - Include the documentation generated by your partner for the catscript programming language
* Section 5: UML - Include and discuss one of the UML diagrams included in this directory
* Section 6: Design trade-offs - You must write this, maybe discuss recursive descent vs. a parser generator?
* Section 7: Software development life cycle model - We did Test Driven Development, please discuss your experience with it

## Section 1: Program
[sourcecode](https://github.com/Gearhartlove/CatScript-Compiler/blob/master/capstone/source.zip)
## Section 2: Teamwork

## Section 3: Design Pattern
Catscript uses the memoization patter to memoize type access in the getListType() method in the CatscriptType.java code. This pattern "accelerates performance by caching the return values of expensive function calls" ([cloudsavvit.com](https://www.cloudsavvyit.com/12446/what-is-memoization-and-why-does-it-matter/)). A hashmap is created which stores the catscript type. If the quereid CatscriptType exists in the hashmap, the cached result is returned. If the queired CatscriptType does not yet exist, than a new CatscriptType is instantiated and added to the Hashmap. This removes redunant instances of CatscriptType ListTypes existing, when they are already instantiated.

## Section 4: Technical Writing
// ask about documentation here
## Section 5: UML Sequence Diagrams
1. Parser
2. Tokenizer
## Section 6: Design Tradeoffs
While programming CatScript, a number of design decisions were made. The most prevelent is why we chose a recursive descent parser, as opposed to a more conventional parser generator (such as [ANTLR](https://www.antlr.org/)). The primary reasons are readability, educational, and debugability. When writing a recursive descent parser, it is much easier to . . . 
## Section 7: Software Development Life Cycle Model
A Test Driven Development software development life cycle model was used throughout the entire project. Hundreds of tests were provided which correlated to specific milestones during the compiler's development. For example, the tokenizer, parser, and bytecode compilation all included tests which must pass in order for the compiler to work. This process was seemless, easy to follow, and efficient when designing the various components of the compiler.
